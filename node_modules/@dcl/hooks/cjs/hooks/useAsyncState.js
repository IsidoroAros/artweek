"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAsyncState = exports.createAsyncStateState = void 0;
const react_1 = require("react");
const sentry_1 = require("../utils/development/sentry");
/**
 * Create a state object for the useAsyncState hook
 * @param initialValue - The initial value of the state
 * @param callWithTruthyDeps - Whether to call the async function only when all dependencies are truthy
 * @returns An object with the state properties
 */
const createAsyncStateState = () => {
    return {
        version: 0,
        loading: false,
        time: 0,
        error: null,
        loaded: false,
        reload: () => { },
        set: () => { },
    };
};
exports.createAsyncStateState = createAsyncStateState;
/**
 * Execute and async function and save the result in the component memory,
 * it will execute again each time deps change, and it return only the result
 * for the latest change
 *
 * @param callback - async function
 * @param deps - dependency list
 * @param options.initialValue - initial memo value (default=null)
 * @param options.callWithTruthyDeps - if true the effect will be executed only when
 *   all values in the dependency list are evaluated as true
 */
const useAsyncState = (callback, deps = [], options = {}) => {
    var _a;
    const [state, setState] = (0, react_1.useState)({
        version: 0,
        loading: false,
        value: ((_a = options.initialValue) !== null && _a !== void 0 ? _a : null),
        time: 0,
        error: null,
    });
    const load = (0, react_1.useCallback)(() => {
        if (options.callWithTruthyDeps &&
            deps.some((dep) => Boolean(dep) === false)) {
            return;
        }
        setState((current) => (Object.assign(Object.assign({}, current), { loading: true, version: current.version + 1 })));
    }, [state, options.callWithTruthyDeps, ...deps]);
    (0, react_1.useEffect)(() => {
        load();
    }, deps);
    (0, react_1.useEffect)(() => {
        if (!state.loading) {
            return;
        }
        let cancelled = false;
        const loading = false;
        const initial = Date.now();
        Promise.resolve()
            .then(() => callback())
            .then((value) => {
            if (cancelled) {
                return;
            }
            setState((current) => (Object.assign(Object.assign({}, current), { value, error: null, loading, time: Date.now() - initial })));
        })
            .catch((err) => {
            console.error(err);
            (0, sentry_1.sentry)((sentry) => sentry.captureException(err));
            if (cancelled) {
                return;
            }
            setState((current) => (Object.assign(Object.assign({}, current), { value: current.value, error: err, loading, time: Date.now() - initial })));
        });
        return () => {
            cancelled = true;
        };
    }, [state]);
    const set = (0, react_1.useCallback)((value) => {
        const newValue = typeof value === "function"
            ? value(state.value)
            : value;
        setState((current) => (Object.assign(Object.assign({}, current), { value: newValue })));
    }, [state]);
    const actions = (0, react_1.useMemo)(() => ({
        version: state.version,
        loading: state.loading,
        error: state.error,
        time: state.time,
        loaded: state.version !== 0,
        reload: load,
        set,
    }), [state, load, set]);
    return [state.value, actions];
};
exports.useAsyncState = useAsyncState;
//# sourceMappingURL=useAsyncState.js.map