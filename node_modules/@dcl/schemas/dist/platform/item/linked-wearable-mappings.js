"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMappingsHelper = exports.AddMappingError = exports.Mappings = exports.Mapping = exports.MultipleMapping = exports.RangeMapping = exports.AnyMapping = exports.SingleMapping = exports.ContractNetwork = exports.MappingType = void 0;
const validation_1 = require("../../validation");
/**
 * MappingType
 * @alpha
 */
var MappingType;
(function (MappingType) {
    MappingType["SINGLE"] = "single";
    MappingType["ANY"] = "any";
    MappingType["MULTIPLE"] = "multiple";
    MappingType["RANGE"] = "range";
})(MappingType = exports.MappingType || (exports.MappingType = {}));
/**
 * Network
 * @alpha
 */
var ContractNetwork;
(function (ContractNetwork) {
    ContractNetwork["MAINNET"] = "mainnet";
    ContractNetwork["MATIC"] = "matic";
    ContractNetwork["SEPOLIA"] = "sepolia";
    ContractNetwork["AMOY"] = "amoy";
})(ContractNetwork = exports.ContractNetwork || (exports.ContractNetwork = {}));
/**
 * SingleMapping
 * @alpha
 */
var SingleMapping;
(function (SingleMapping) {
    SingleMapping.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: MappingType.SINGLE },
            id: { type: 'string', pattern: '^[0-9]+$' }
        },
        required: ['type', 'id'],
        additionalProperties: false
    };
    SingleMapping.validate = (0, validation_1.generateLazyValidator)(SingleMapping.schema);
})(SingleMapping = exports.SingleMapping || (exports.SingleMapping = {}));
/**
 * AnyMapping
 * @alpha
 */
var AnyMapping;
(function (AnyMapping) {
    AnyMapping.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: MappingType.ANY }
        },
        required: ['type'],
        additionalProperties: false
    };
    AnyMapping.validate = (0, validation_1.generateLazyValidator)(AnyMapping.schema);
})(AnyMapping = exports.AnyMapping || (exports.AnyMapping = {}));
/**
 * RangeMapping
 * @alpha
 */
var RangeMapping;
(function (RangeMapping) {
    RangeMapping._fromLessThanOrEqualTo = {
        keyword: '_fromLessThanOrEqualTo',
        validate: function validate(schema, data) {
            if (!data || !data.from || !data.to) {
                return false;
            }
            let { to, from } = data;
            if (typeof from !== 'bigint' || typeof to !== 'bigint') {
                from = BigInt(from);
                to = BigInt(to);
            }
            return from <= to;
        },
        errors: false
    };
    RangeMapping.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: MappingType.RANGE },
            from: { type: 'string', pattern: '^[0-9]+$' },
            to: { type: 'string', pattern: '^[0-9]+$' }
        },
        required: ['type', 'from', 'to'],
        additionalProperties: false,
        _fromLessThanOrEqualTo: true
    };
    RangeMapping.validate = (0, validation_1.generateLazyValidator)(RangeMapping.schema, [RangeMapping._fromLessThanOrEqualTo]);
})(RangeMapping = exports.RangeMapping || (exports.RangeMapping = {}));
/**
 * MultipleMapping
 * @alpha
 */
var MultipleMapping;
(function (MultipleMapping) {
    MultipleMapping.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: MappingType.MULTIPLE },
            ids: {
                type: 'array',
                items: {
                    type: 'string',
                    pattern: '^[0-9]+$'
                },
                minItems: 1,
                uniqueItems: true
            }
        },
        required: ['type', 'ids'],
        additionalProperties: false
    };
    MultipleMapping.validate = (0, validation_1.generateLazyValidator)(MultipleMapping.schema);
})(MultipleMapping = exports.MultipleMapping || (exports.MultipleMapping = {}));
/**
 * Mapping
 * @alpha
 */
var Mapping;
(function (Mapping) {
    Mapping.schema = {
        type: 'object',
        properties: {
            type: {
                type: 'string',
                enum: Object.values(MappingType)
            }
        },
        required: ['type'],
        oneOf: [SingleMapping.schema, AnyMapping.schema, RangeMapping.schema, MultipleMapping.schema]
    };
    Mapping.validate = (0, validation_1.generateLazyValidator)(Mapping.schema, [
        RangeMapping._fromLessThanOrEqualTo
    ]);
})(Mapping = exports.Mapping || (exports.Mapping = {}));
/**
 * Mappings
 * @alpha
 */
var Mappings;
(function (Mappings) {
    Mappings._isMappingsValid = {
        keyword: '_isMappingsValid',
        validate: function (_schema, data) {
            try {
                createMappingsHelper(data);
            }
            catch (_) {
                return false;
            }
            return true;
        },
        errors: false
    };
    Mappings.innerSchema = {
        type: 'object',
        patternProperties: {
            '^0x[0-9a-fA-F]{40}$': {
                type: 'array',
                items: Mapping.schema
            }
        },
        minProperties: 1,
        required: [],
        additionalProperties: false
    };
    const properties = Object.values(ContractNetwork).reduce((acc, network) => {
        acc[network] = Mappings.innerSchema;
        return acc;
    }, {});
    Mappings.schema = {
        type: 'object',
        properties,
        minProperties: 1,
        additionalProperties: false,
        _isMappingsValid: true
    };
    Mappings.validate = (0, validation_1.generateLazyValidator)(Mappings.schema, [
        RangeMapping._fromLessThanOrEqualTo,
        Mappings._isMappingsValid
    ]);
})(Mappings = exports.Mappings || (exports.Mappings = {}));
class AddMappingError extends Error {
    constructor(message, existingMapping, conflictingMapping) {
        super(message);
        this.existingMapping = existingMapping;
        this.conflictingMapping = conflictingMapping;
    }
}
exports.AddMappingError = AddMappingError;
function createMappingsHelper(initial = {}) {
    const mappings = {};
    for (const [network, contracts] of Object.entries(initial)) {
        mappings[network] = {};
        for (const [contractAddress, mappingsArray] of Object.entries(contracts)) {
            for (const mapping of mappingsArray) {
                // We add them this way to make sure we build a valid object
                addMapping(network, contractAddress, mapping);
            }
        }
    }
    function getMappings() {
        return JSON.parse(JSON.stringify(mappings));
    }
    function isInRange(id, from, to) {
        const idBigInt = BigInt(id);
        return idBigInt >= BigInt(from) && idBigInt <= BigInt(to);
    }
    function singleOverlapCheck(mapping, other) {
        switch (other.type) {
            case MappingType.SINGLE:
                return mapping.id === other.id;
            case MappingType.MULTIPLE:
                return other.ids.includes(mapping.id);
            case MappingType.RANGE:
                return isInRange(mapping.id, other.from, other.to);
            default:
                return false;
        }
    }
    function multipleOverlapCheck(mapping, other) {
        switch (other.type) {
            case MappingType.SINGLE:
                return mapping.ids.includes(other.id);
            case MappingType.MULTIPLE:
                return mapping.ids.some((id) => other.ids.includes(id));
            case MappingType.RANGE:
                return mapping.ids.some((id) => isInRange(id, other.from, other.to));
            default:
                return false;
        }
    }
    function rangeOverlapCheck(mapping, other) {
        switch (other.type) {
            case MappingType.SINGLE:
                return isInRange(other.id, mapping.from, mapping.to);
            case MappingType.MULTIPLE:
                return other.ids.some((id) => isInRange(id, mapping.from, mapping.to));
            case MappingType.RANGE:
                return BigInt(mapping.from) <= BigInt(other.to) && BigInt(mapping.to) >= BigInt(other.from);
        }
    }
    function overlappingCheck(mapping, other) {
        if (mapping.type === MappingType.ANY || other.type === MappingType.ANY) {
            return true;
        }
        switch (mapping.type) {
            case MappingType.SINGLE:
                return singleOverlapCheck(mapping, other);
            case MappingType.MULTIPLE:
                return multipleOverlapCheck(mapping, other);
            case MappingType.RANGE:
                return rangeOverlapCheck(mapping, other);
        }
    }
    function addMapping(network, contractAddress, mapping) {
        var _a, _b;
        const lowerContractAddress = contractAddress.toLowerCase();
        mappings[network] = (_a = mappings[network]) !== null && _a !== void 0 ? _a : {};
        mappings[network][lowerContractAddress] = (_b = mappings[network][lowerContractAddress]) !== null && _b !== void 0 ? _b : [];
        for (const existingMapping of mappings[network][lowerContractAddress]) {
            if (overlappingCheck(existingMapping, mapping)) {
                throw new AddMappingError(`Cannot add mapping to contract ${lowerContractAddress} on network ${network} because it overlaps with existing mapping`, existingMapping, mapping);
            }
        }
        mappings[network][lowerContractAddress].push(mapping);
    }
    function includesNft(network, contractAddress, tokenId) {
        var _a;
        if (!((_a = mappings[network]) === null || _a === void 0 ? void 0 : _a[contractAddress])) {
            return false;
        }
        return mappings[network][contractAddress].some((mapping) => {
            switch (mapping.type) {
                case MappingType.SINGLE:
                    return mapping.id === tokenId;
                case MappingType.ANY:
                    return true;
                case MappingType.MULTIPLE:
                    return mapping.ids.includes(tokenId);
                case MappingType.RANGE:
                    return BigInt(tokenId) >= BigInt(mapping.from) && BigInt(tokenId) <= BigInt(mapping.to);
            }
        });
    }
    return {
        addMapping,
        getMappings,
        includesNft
    };
}
exports.createMappingsHelper = createMappingsHelper;
//# sourceMappingURL=linked-wearable-mappings.js.map