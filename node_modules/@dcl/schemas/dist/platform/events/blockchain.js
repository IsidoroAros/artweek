"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionCreatedEvent = exports.RoyaltiesEarnedEvent = exports.RentalStartedEvent = exports.RentalEndedEvent = exports.ItemPublishedEvent = exports.ItemSoldEvent = exports.BidAcceptedEvent = void 0;
const validation_1 = require("../../validation");
const base_1 = require("./base");
var BidAcceptedEvent;
(function (BidAcceptedEvent) {
    BidAcceptedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.BID_ACCEPTED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    address: { type: 'string' },
                    image: { type: 'string' },
                    seller: { type: 'string' },
                    category: { type: 'string' },
                    rarity: { type: 'string', nullable: true },
                    link: { type: 'string' },
                    nftName: { type: 'string', nullable: true },
                    price: { type: 'string' },
                    title: { type: 'string' },
                    description: { type: 'string' },
                    network: { type: 'string' }
                },
                required: ['address', 'image', 'seller', 'category', 'link', 'price', 'title', 'network']
            }
        },
        required: ['type', 'subType', 'key', 'timestamp', 'metadata'],
        additionalProperties: true
    };
    BidAcceptedEvent.validate = (0, validation_1.generateLazyValidator)(BidAcceptedEvent.schema);
})(BidAcceptedEvent = exports.BidAcceptedEvent || (exports.BidAcceptedEvent = {}));
var ItemSoldEvent;
(function (ItemSoldEvent) {
    ItemSoldEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.ITEM_SOLD },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    address: { type: 'string' },
                    image: { type: 'string' },
                    buyer: { type: 'string' },
                    seller: { type: 'string' },
                    category: { type: 'string' },
                    rarity: { type: 'string', nullable: true },
                    link: { type: 'string' },
                    nftName: { type: 'string', nullable: true },
                    tokenId: { type: 'string' },
                    network: { type: 'string' },
                    title: { type: 'string' },
                    description: { type: 'string' }
                },
                required: ['address', 'image', 'seller', 'category', 'link', 'network', 'title', 'description']
            }
        },
        required: ['type', 'subType', 'key', 'timestamp', 'metadata'],
        additionalProperties: false
    };
    ItemSoldEvent.validate = (0, validation_1.generateLazyValidator)(ItemSoldEvent.schema);
})(ItemSoldEvent = exports.ItemSoldEvent || (exports.ItemSoldEvent = {}));
var ItemPublishedEvent;
(function (ItemPublishedEvent) {
    ItemPublishedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.ITEM_PUBLISHED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    creator: { type: 'string' },
                    category: { type: 'string' },
                    rarity: { type: 'string', nullable: true },
                    itemId: { type: 'string' },
                    network: { type: 'string' },
                    urn: { type: 'string' }
                },
                required: ['creator', 'category', 'itemId', 'network', 'urn']
            }
        },
        required: ['type', 'subType', 'key', 'timestamp', 'metadata'],
        additionalProperties: false
    };
    ItemPublishedEvent.validate = (0, validation_1.generateLazyValidator)(ItemPublishedEvent.schema);
})(ItemPublishedEvent = exports.ItemPublishedEvent || (exports.ItemPublishedEvent = {}));
var RentalEndedEvent;
(function (RentalEndedEvent) {
    RentalEndedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.RENTAL_ENDED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    address: { type: 'string' },
                    contract: { type: 'string' },
                    land: { type: 'string', nullable: true },
                    lessor: { type: 'string' },
                    tenant: { type: 'string' },
                    operator: { type: 'string' },
                    startedAt: { type: 'string' },
                    endedAt: { type: 'string' },
                    tokenId: { type: 'string' },
                    link: { type: 'string' },
                    title: { type: 'string' },
                    description: { type: 'string', nullable: true }
                },
                required: [
                    'address',
                    'contract',
                    'lessor',
                    'tenant',
                    'operator',
                    'startedAt',
                    'endedAt',
                    'tokenId',
                    'link',
                    'title'
                ]
            }
        },
        required: ['type', 'subType', 'key', 'timestamp', 'metadata'],
        additionalProperties: false
    };
    RentalEndedEvent.validate = (0, validation_1.generateLazyValidator)(RentalEndedEvent.schema);
})(RentalEndedEvent = exports.RentalEndedEvent || (exports.RentalEndedEvent = {}));
var RentalStartedEvent;
(function (RentalStartedEvent) {
    RentalStartedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.RENTAL_STARTED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    address: { type: 'string' },
                    contract: { type: 'string' },
                    land: { type: 'string', nullable: true },
                    lessor: { type: 'string' },
                    tenant: { type: 'string' },
                    operator: { type: 'string' },
                    startedAt: { type: 'string' },
                    endedAt: { type: 'string' },
                    tokenId: { type: 'string' },
                    link: { type: 'string' },
                    title: { type: 'string' },
                    description: { type: 'string', nullable: true }
                },
                required: [
                    'address',
                    'contract',
                    'lessor',
                    'tenant',
                    'operator',
                    'startedAt',
                    'endedAt',
                    'tokenId',
                    'link',
                    'title'
                ]
            }
        },
        required: ['type', 'subType', 'key', 'timestamp', 'metadata'],
        additionalProperties: false
    };
    RentalStartedEvent.validate = (0, validation_1.generateLazyValidator)(RentalStartedEvent.schema);
})(RentalStartedEvent = exports.RentalStartedEvent || (exports.RentalStartedEvent = {}));
var RoyaltiesEarnedEvent;
(function (RoyaltiesEarnedEvent) {
    RoyaltiesEarnedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.ROYALTIES_EARNED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    address: { type: 'string' },
                    image: { type: 'string' },
                    category: { type: 'string' },
                    rarity: { type: 'string', nullable: true },
                    link: { type: 'string' },
                    nftName: { type: 'string', nullable: true },
                    royaltiesCut: { type: 'string' },
                    royaltiesCollector: { type: 'string' },
                    network: { type: 'string' },
                    title: { type: 'string' },
                    description: { type: 'string', nullable: true }
                },
                required: ['address', 'image', 'category', 'link', 'royaltiesCut', 'royaltiesCollector', 'network', 'title']
            }
        },
        required: ['type', 'subType', 'metadata'],
        additionalProperties: false
    };
    RoyaltiesEarnedEvent.validate = (0, validation_1.generateLazyValidator)(RoyaltiesEarnedEvent.schema);
})(RoyaltiesEarnedEvent = exports.RoyaltiesEarnedEvent || (exports.RoyaltiesEarnedEvent = {}));
var CollectionCreatedEvent;
(function (CollectionCreatedEvent) {
    CollectionCreatedEvent.schema = {
        type: 'object',
        properties: {
            type: { type: 'string', const: base_1.Events.Type.BLOCKCHAIN },
            subType: { type: 'string', const: base_1.Events.SubType.Blockchain.COLLECTION_CREATED },
            key: { type: 'string' },
            timestamp: { type: 'number', minimum: 0 },
            metadata: {
                type: 'object',
                properties: {
                    creator: { type: 'string' },
                    name: { type: 'string' }
                },
                required: ['creator', 'name']
            }
        },
        required: ['type', 'subType', 'metadata'],
        additionalProperties: false
    };
    CollectionCreatedEvent.validate = (0, validation_1.generateLazyValidator)(CollectionCreatedEvent.schema);
})(CollectionCreatedEvent = exports.CollectionCreatedEvent || (exports.CollectionCreatedEvent = {}));
//# sourceMappingURL=blockchain.js.map