"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parcel = exports.PARCEL_LIMITS = void 0;
const validation_1 = require("../validation");
const parcel_exceptions_1 = require("./parcel-exceptions");
/**
 * Standard limits for parcels in Decentraland
 * @public
 */
exports.PARCEL_LIMITS = {
    minX: -150,
    maxX: 150,
    minY: -150,
    maxY: 150
};
/**
 * Namespace with utilities to validate parcels
 * @public
 */
var Parcel;
(function (Parcel) {
    /**
     * Custom validation to check if coordinates are within limits
     */
    Parcel._isInLimits = {
        keyword: '_isInLimits',
        validate: function validate(schema, data) {
            if (!data || typeof data.x !== 'number' || typeof data.y !== 'number') {
                return false;
            }
            return isInStandardBounds(data) || (0, parcel_exceptions_1.isInExceptionBlock)(data.x, data.y);
        },
        errors: false
    };
    Parcel.schema = {
        type: 'object',
        required: ['x', 'y'],
        properties: {
            x: {
                type: 'number'
            },
            y: {
                type: 'number'
            }
        },
        _isInLimits: true,
        additionalProperties: false
    };
    Parcel.validate = (0, validation_1.generateLazyValidator)(Parcel.schema, [Parcel._isInLimits]);
    // Converts coordinates to string in "x,y" format
    function parcelToString({ x, y }) {
        return `${x},${y}`;
    }
    Parcel.parcelToString = parcelToString;
    // Converts a string in "x,y" format to a Parcel object
    function stringToParcel(position) {
        const match = position.match(/^(-?\d+),(-?\d+)$/);
        if (!match)
            return null;
        const [, xStr, yStr] = match;
        const x = parseInt(xStr, 10);
        const y = parseInt(yStr, 10);
        return { x, y };
    }
    Parcel.stringToParcel = stringToParcel;
    /**
     * Validates if a string in "x,y" format represents a valid parcel
     */
    function isParcelStringValid(parcelString) {
        const parcel = stringToParcel(parcelString);
        if (!parcel)
            return false;
        return Parcel.validate(parcel);
    }
    Parcel.isParcelStringValid = isParcelStringValid;
    /**
     * Checks if a parcel is within the standard bounds
     */
    function isInStandardBounds(parcel) {
        const { x, y } = parcel;
        return x >= exports.PARCEL_LIMITS.minX && x <= exports.PARCEL_LIMITS.maxX && y >= exports.PARCEL_LIMITS.minY && y <= exports.PARCEL_LIMITS.maxY;
    }
    Parcel.isInStandardBounds = isInStandardBounds;
    /**
     * Checks if a parcel is a known exception
     */
    function isExceptionParcel(parcel) {
        return (0, parcel_exceptions_1.isInExceptionBlock)(parcel.x, parcel.y);
    }
    Parcel.isExceptionParcel = isExceptionParcel;
    /**
     * Checks if a parcel is within bounds or is a valid exception
     */
    function isInBounds(parcel) {
        return isInStandardBounds(parcel) || isExceptionParcel(parcel);
    }
    Parcel.isInBounds = isInBounds;
    /**
     * Validates if a parcel is valid (satisfies the schema and is within bounds or is an exception)
     */
    function isValid(parcel) {
        return Parcel.validate(parcel);
    }
    Parcel.isValid = isValid;
    /**
     * Validates if a parcel in string format is valid
     */
    function isValidString(parcelString) {
        const parcel = stringToParcel(parcelString);
        if (!parcel)
            return false;
        return Parcel.validate(parcel);
    }
    Parcel.isValidString = isValidString;
})(Parcel = exports.Parcel || (exports.Parcel = {}));
//# sourceMappingURL=parcel-validation.js.map